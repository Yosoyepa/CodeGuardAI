@startuml uml-act-parallel-agent-execution
skinparam backgroundColor #FFFFFF
skinparam activityBackgroundColor #E7F5FF
skinparam activityBorderColor #1E40AF
skinparam activityFontSize 10
skinparam activityDiamondBackgroundColor #FEF3C7

title Activity Diagram - Parallel Agent Execution (ThreadPoolExecutor)

start

:OrchestratorAgent.orchestrate_analysis(context);

:Create ThreadPoolExecutor(max_workers=4);

:Register agents:\n• SecurityAgent\n• QualityAgent\n• PerformanceAgent\n• StyleAgent;

partition "Parallel Execution (Fork-Join Pattern)" {
  fork
    :SecurityAgent Thread;
    :Parse code with AST module;
    :Detect dangerous functions\n(eval, exec, pickle);
    :Detect SQL injection patterns;
    :Detect hardcoded credentials;
    :Emit AGENT_COMPLETED event;
    :Return findings list;
  fork again
    :QualityAgent Thread;
    :Analyze with Radon library;
    :Calculate cyclomatic complexity\nfor each function;
    :Detect code duplication\n(threshold: 20%);
    :Measure function length\n(threshold: 100 lines);
    :Emit AGENT_COMPLETED event;
    :Return findings list;
  fork again
    :PerformanceAgent Thread;
    :Visit AST nodes;
    :Detect nested loops\n(threshold: 3 levels);
    :Identify inefficient patterns\n(O(n²) algorithms);
    :Flag expensive operations in loops\n(I/O, network calls);
    :Emit AGENT_COMPLETED event;
    :Return findings list;
  fork again
    :StyleAgent Thread;
    :Run pylint analyzer;
    :Run flake8 analyzer;
    :Check PEP 8 compliance\n(naming, spacing, line length);
    :Validate docstrings;
    :Detect unused imports;
    :Emit AGENT_COMPLETED event;
    :Return findings list;
  end fork
}

:Wait for all futures to complete\n(ThreadPoolExecutor.wait);

if (Any agent timed out\nafter 30 seconds?) then (yes)
  :Mark timed_out agents;
  :Save partial results from\ncompleted agents;
else (no)
  :All agents completed successfully;
endif

:Merge findings from all agents\ninto single list;

:Remove duplicate findings\n(same issue_type + line_number);

if (Any findings found?) then (yes)
  :Sort by severity\n(CRITICAL → HIGH → MEDIUM → LOW);
else (no)
  :Set findings = [];
endif

:Emit AGENTS_EXECUTION_COMPLETED event;

:Return aggregated results to Orchestrator\n{findings[], execution_time_ms, agent_statuses};

stop

note right
  **Performance Metrics:**
  • Sequential time (4 agents): ~15 seconds
  • Parallel time (4 agents): ~4 seconds
  • Speedup: 3.75×
  • CPU utilization: 80-90%
  
  **Timeout Strategy:**
  • Per-agent timeout: 30 seconds
  • Graceful degradation: continue with others
  • Log timed_out agents for debugging
  
  **Thread Safety:**
  • SharedThreadSafeQueue for results
  • Lock-free aggregation
  • Atomic event publishing
end note

@enduml
